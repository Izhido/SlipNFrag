#include "Scene.h"
#include "VrApi_Helpers.h"
#include "AppState.h"
#include "VrApi_Vulkan.h"
#include "VulkanCallWrappers.h"
#include <android/log.h>
#include "sys_ovr.h"
#include "MemoryAllocateInfo.h"
#include "stb_image.h"
#include "vid_ovr.h"

void Scene::Create(AppState& appState, VkCommandBufferAllocateInfo& commandBufferAllocateInfo, VkCommandBuffer& setupCommandBuffer, VkCommandBufferBeginInfo& commandBufferBeginInfo, VkSubmitInfo& setupSubmitInfo, Instance& instance, VkFenceCreateInfo& fenceCreateInfo, struct android_app* app)
{
	int frameFlags = 0;
	frameFlags |= VRAPI_FRAME_FLAG_FLUSH;
	ovrLayerProjection2 blackLayer = vrapi_DefaultLayerBlackProjection2();
	blackLayer.Header.Flags |= VRAPI_FRAME_LAYER_FLAG_INHIBIT_SRGB_FRAMEBUFFER;
	ovrLayerLoadingIcon2 iconLayer = vrapi_DefaultLayerLoadingIcon2();
	iconLayer.Header.Flags |= VRAPI_FRAME_LAYER_FLAG_INHIBIT_SRGB_FRAMEBUFFER;
	const ovrLayerHeader2* layers[] { &blackLayer.Header, &iconLayer.Header };
	ovrSubmitFrameDescription2 frameDesc { };
	frameDesc.Flags = frameFlags;
	frameDesc.SwapInterval = 1;
	frameDesc.FrameIndex = appState.FrameIndex;
	frameDesc.DisplayTime = appState.DisplayTime;
	frameDesc.LayerCount = 2;
	frameDesc.Layers = layers;
	vrapi_SubmitFrame2(appState.Ovr, &frameDesc);
	appState.ScreenWidth = 960;
	appState.ScreenHeight = 600;
	appState.ConsoleWidth = 320;
	appState.ConsoleHeight = 200;
	appState.Console.SwapChain = vrapi_CreateTextureSwapChain3(VRAPI_TEXTURE_TYPE_2D, VK_FORMAT_R8G8B8A8_UNORM, appState.ScreenWidth, appState.ScreenHeight, 1, 3);
	appState.Console.View.colorSwapChain.SwapChain = appState.Console.SwapChain;
	appState.Console.View.colorSwapChain.SwapChainLength = vrapi_GetTextureSwapChainLength(appState.Console.View.colorSwapChain.SwapChain);
	appState.Console.View.colorSwapChain.ColorTextures.resize(appState.Console.View.colorSwapChain.SwapChainLength);
	for (auto i = 0; i < appState.Console.View.colorSwapChain.SwapChainLength; i++)
	{
		appState.Console.View.colorSwapChain.ColorTextures[i] = vrapi_GetTextureSwapChainBufferVulkan(appState.Console.View.colorSwapChain.SwapChain, i);
	}
	uint32_t attachmentCount = 0;
	VkAttachmentDescription attachments[2] { };
	attachments[attachmentCount].format = VK_FORMAT_R8G8B8A8_UNORM;
	attachments[attachmentCount].samples = VK_SAMPLE_COUNT_4_BIT;
	attachments[attachmentCount].loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR;
	attachments[attachmentCount].storeOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;
	attachments[attachmentCount].stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;
	attachments[attachmentCount].stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;
	attachments[attachmentCount].initialLayout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;
	attachments[attachmentCount].finalLayout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;
	attachmentCount++;
	attachments[attachmentCount].format = VK_FORMAT_R8G8B8A8_UNORM;
	attachments[attachmentCount].samples = VK_SAMPLE_COUNT_1_BIT;
	attachments[attachmentCount].loadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;
	attachments[attachmentCount].storeOp = VK_ATTACHMENT_STORE_OP_STORE;
	attachments[attachmentCount].stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;
	attachments[attachmentCount].stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;
	attachments[attachmentCount].initialLayout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;
	attachments[attachmentCount].finalLayout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;
	attachmentCount++;
	VkAttachmentReference colorAttachmentReference;
	colorAttachmentReference.attachment = 0;
	colorAttachmentReference.layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;
	VkAttachmentReference resolveAttachmentReference;
	resolveAttachmentReference.attachment = 1;
	resolveAttachmentReference.layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;
	VkSubpassDescription subpassDescription { };
	subpassDescription.pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS;
	subpassDescription.colorAttachmentCount = 1;
	subpassDescription.pColorAttachments = &colorAttachmentReference;
	subpassDescription.pResolveAttachments = &resolveAttachmentReference;
	VkRenderPassCreateInfo renderPassCreateInfo { };
	renderPassCreateInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO;
	renderPassCreateInfo.attachmentCount = attachmentCount;
	renderPassCreateInfo.pAttachments = attachments;
	renderPassCreateInfo.subpassCount = 1;
	renderPassCreateInfo.pSubpasses = &subpassDescription;
	VK(appState.Device.vkCreateRenderPass(appState.Device.device, &renderPassCreateInfo, nullptr, &appState.Console.RenderPass));
	appState.Console.View.framebuffer.colorTextureSwapChain = appState.Console.View.colorSwapChain.SwapChain;
	appState.Console.View.framebuffer.swapChainLength = appState.Console.View.colorSwapChain.SwapChainLength;
	appState.Console.View.framebuffer.colorTextures.resize(appState.Console.View.framebuffer.swapChainLength);
	appState.Console.View.framebuffer.startBarriers.resize(appState.Console.View.framebuffer.swapChainLength);
	appState.Console.View.framebuffer.endBarriers.resize(appState.Console.View.framebuffer.swapChainLength);
	appState.Console.View.framebuffer.framebuffers.resize(appState.Console.View.framebuffer.swapChainLength);
	appState.Console.View.framebuffer.width = appState.ScreenWidth;
	appState.Console.View.framebuffer.height = appState.ScreenHeight;
	for (auto i = 0; i < appState.Console.View.framebuffer.swapChainLength; i++)
	{
		auto& texture = appState.Console.View.framebuffer.colorTextures[i];
		texture.width = appState.ScreenWidth;
		texture.height = appState.ScreenHeight;
		texture.layerCount = 1;
		texture.image = appState.Console.View.colorSwapChain.ColorTextures[i];
		VK(appState.Device.vkAllocateCommandBuffers(appState.Device.device, &commandBufferAllocateInfo, &setupCommandBuffer));
		VK(appState.Device.vkBeginCommandBuffer(setupCommandBuffer, &commandBufferBeginInfo));
		VkImageMemoryBarrier imageMemoryBarrier { };
		imageMemoryBarrier.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
		imageMemoryBarrier.dstAccessMask = VK_ACCESS_SHADER_READ_BIT;
		imageMemoryBarrier.newLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
		imageMemoryBarrier.image = appState.Console.View.colorSwapChain.ColorTextures[i];
		imageMemoryBarrier.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
		imageMemoryBarrier.subresourceRange.levelCount = 1;
		imageMemoryBarrier.subresourceRange.layerCount = texture.layerCount;
		VC(appState.Device.vkCmdPipelineBarrier(setupCommandBuffer, VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT, VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT, 0, 0, nullptr, 0, nullptr, 1, &imageMemoryBarrier));
		VK(appState.Device.vkEndCommandBuffer(setupCommandBuffer));
		VK(appState.Device.vkQueueSubmit(appState.Context.queue, 1, &setupSubmitInfo, VK_NULL_HANDLE));
		VK(appState.Device.vkQueueWaitIdle(appState.Context.queue));
		VC(appState.Device.vkFreeCommandBuffers(appState.Device.device, appState.Context.commandPool, 1, &setupCommandBuffer));
		VkImageViewCreateInfo imageViewCreateInfo { };
		imageViewCreateInfo.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;
		imageViewCreateInfo.image = texture.image;
		imageViewCreateInfo.viewType = VK_IMAGE_VIEW_TYPE_2D;
		imageViewCreateInfo.format = VK_FORMAT_R8G8B8A8_UNORM;
		imageViewCreateInfo.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
		imageViewCreateInfo.subresourceRange.levelCount = 1;
		imageViewCreateInfo.subresourceRange.layerCount = texture.layerCount;
		VK(appState.Device.vkCreateImageView(appState.Device.device, &imageViewCreateInfo, nullptr, &texture.view));
		auto& startBarrier = appState.Console.View.framebuffer.startBarriers[i];
		startBarrier.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
		startBarrier.srcAccessMask = VK_ACCESS_SHADER_READ_BIT;
		startBarrier.dstAccessMask = VK_ACCESS_COLOR_ATTACHMENT_READ_BIT | VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT;
		startBarrier.oldLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
		startBarrier.newLayout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;
		startBarrier.image = texture.image;
		startBarrier.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
		startBarrier.subresourceRange.levelCount = 1;
		startBarrier.subresourceRange.layerCount = texture.layerCount;
		auto& endBarrier = appState.Console.View.framebuffer.endBarriers[i];
		endBarrier.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
		endBarrier.srcAccessMask = VK_ACCESS_COLOR_ATTACHMENT_READ_BIT | VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT;
		endBarrier.dstAccessMask = VK_ACCESS_SHADER_READ_BIT;
		endBarrier.oldLayout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;
		endBarrier.newLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
		endBarrier.image = texture.image;
		endBarrier.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
		endBarrier.subresourceRange.levelCount = 1;
		endBarrier.subresourceRange.layerCount = texture.layerCount;
	}
	VkFormatProperties props;
	VC(instance.vkGetPhysicalDeviceFormatProperties(appState.Device.physicalDevice, VK_FORMAT_R8G8B8A8_UNORM, &props));
	if ((props.optimalTilingFeatures & VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT) == 0)
	{
		__android_log_print(ANDROID_LOG_ERROR, LOG_TAG, "Scene::Create(): Color attachment bit in texture is not defined.");
		vrapi_Shutdown();
		exit(0);
	}
	auto& texture = appState.Console.View.framebuffer.renderTexture;
	texture.width = appState.Console.View.framebuffer.width;
	texture.height = appState.Console.View.framebuffer.height;
	texture.layerCount = 1;
	VkImageCreateInfo imageCreateInfo { };
	imageCreateInfo.sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO;
	imageCreateInfo.imageType = VK_IMAGE_TYPE_2D;
	imageCreateInfo.format = VK_FORMAT_R8G8B8A8_UNORM;
	imageCreateInfo.extent.width = texture.width;
	imageCreateInfo.extent.height = texture.height;
	imageCreateInfo.extent.depth = 1;
	imageCreateInfo.mipLevels = 1;
	imageCreateInfo.arrayLayers = texture.layerCount;
	imageCreateInfo.samples = VK_SAMPLE_COUNT_4_BIT;
	imageCreateInfo.tiling = VK_IMAGE_TILING_OPTIMAL;
	imageCreateInfo.usage = VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT;
	imageCreateInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE;
	VK(appState.Device.vkCreateImage(appState.Device.device, &imageCreateInfo, nullptr, &texture.image));
	VkMemoryRequirements memoryRequirements;
	VC(appState.Device.vkGetImageMemoryRequirements(appState.Device.device, texture.image, &memoryRequirements));
	VkMemoryPropertyFlags memFlags = VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT;
	if (appState.Device.supportsLazyAllocate)
	{
		memFlags |= VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT;
	}
	VkMemoryAllocateInfo memoryAllocateInfo { };
	createMemoryAllocateInfo(appState, memoryRequirements, memFlags, memoryAllocateInfo);
	VK(appState.Device.vkAllocateMemory(appState.Device.device, &memoryAllocateInfo, nullptr, &texture.memory));
	VK(appState.Device.vkBindImageMemory(appState.Device.device, texture.image, texture.memory, 0));
	VK(appState.Device.vkAllocateCommandBuffers(appState.Device.device, &commandBufferAllocateInfo, &setupCommandBuffer));
	VK(appState.Device.vkBeginCommandBuffer(setupCommandBuffer, &commandBufferBeginInfo));
	VkImageMemoryBarrier imageMemoryBarrier { };
	imageMemoryBarrier.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
	imageMemoryBarrier.dstAccessMask = VK_ACCESS_SHADER_READ_BIT;
	imageMemoryBarrier.newLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
	imageMemoryBarrier.image = texture.image;
	imageMemoryBarrier.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
	imageMemoryBarrier.subresourceRange.levelCount = 1;
	imageMemoryBarrier.subresourceRange.layerCount = texture.layerCount;
	VC(appState.Device.vkCmdPipelineBarrier(setupCommandBuffer, VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT, VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT, 0, 0, nullptr, 0, nullptr, 1, &imageMemoryBarrier));
	VK(appState.Device.vkEndCommandBuffer(setupCommandBuffer));
	VK(appState.Device.vkQueueSubmit(appState.Context.queue, 1, &setupSubmitInfo, VK_NULL_HANDLE));
	VK(appState.Device.vkQueueWaitIdle(appState.Context.queue));
	VC(appState.Device.vkFreeCommandBuffers(appState.Device.device, appState.Context.commandPool, 1, &setupCommandBuffer));
	VkImageViewCreateInfo imageViewCreateInfo { };
	imageViewCreateInfo.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;
	imageViewCreateInfo.image = texture.image;
	imageViewCreateInfo.viewType = VK_IMAGE_VIEW_TYPE_2D_ARRAY;
	imageViewCreateInfo.format = VK_FORMAT_R8G8B8A8_UNORM;
	imageViewCreateInfo.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
	imageViewCreateInfo.subresourceRange.levelCount = 1;
	imageViewCreateInfo.subresourceRange.layerCount = texture.layerCount;
	VK(appState.Device.vkCreateImageView(appState.Device.device, &imageViewCreateInfo, nullptr, &texture.view));
	VK(appState.Device.vkAllocateCommandBuffers(appState.Device.device, &commandBufferAllocateInfo, &setupCommandBuffer));
	VK(appState.Device.vkBeginCommandBuffer(setupCommandBuffer, &commandBufferBeginInfo));
	imageMemoryBarrier.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
	imageMemoryBarrier.srcAccessMask = VK_ACCESS_SHADER_READ_BIT;
	imageMemoryBarrier.dstAccessMask = VK_ACCESS_COLOR_ATTACHMENT_READ_BIT | VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT;
	imageMemoryBarrier.oldLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
	imageMemoryBarrier.newLayout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;
	imageMemoryBarrier.image = texture.image;
	imageMemoryBarrier.subresourceRange.layerCount = texture.layerCount;
	VC(appState.Device.vkCmdPipelineBarrier(setupCommandBuffer, VK_PIPELINE_STAGE_VERTEX_SHADER_BIT | VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT, VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT, 0, 0, nullptr, 0, nullptr, 1, &imageMemoryBarrier));
	VK(appState.Device.vkEndCommandBuffer(setupCommandBuffer));
	VK(appState.Device.vkQueueSubmit(appState.Context.queue, 1, &setupSubmitInfo, VK_NULL_HANDLE));
	VK(appState.Device.vkQueueWaitIdle(appState.Context.queue));
	VC(appState.Device.vkFreeCommandBuffers(appState.Device.device, appState.Context.commandPool, 1, &setupCommandBuffer));
	for (auto i = 0; i < appState.Console.View.framebuffer.swapChainLength; i++)
	{
		uint32_t attachmentCount = 0;
		VkImageView attachments[2];
		attachments[attachmentCount++] = appState.Console.View.framebuffer.renderTexture.view;
		attachments[attachmentCount++] = appState.Console.View.framebuffer.colorTextures[i].view;
		VkFramebufferCreateInfo framebufferCreateInfo { };
		framebufferCreateInfo.sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO;
		framebufferCreateInfo.renderPass = appState.Console.RenderPass;
		framebufferCreateInfo.attachmentCount = attachmentCount;
		framebufferCreateInfo.pAttachments = attachments;
		framebufferCreateInfo.width = appState.Console.View.framebuffer.width;
		framebufferCreateInfo.height = appState.Console.View.framebuffer.height;
		framebufferCreateInfo.layers = 1;
		VK(appState.Device.vkCreateFramebuffer(appState.Device.device, &framebufferCreateInfo, nullptr, &appState.Console.View.framebuffer.framebuffers[i]));
	}
	appState.Console.View.perImage.resize(appState.Console.View.framebuffer.swapChainLength);
	for (auto& perImage : appState.Console.View.perImage)
	{
		VK(appState.Device.vkAllocateCommandBuffers(appState.Device.device, &commandBufferAllocateInfo, &perImage.commandBuffer));
		VK(appState.Device.vkCreateFence(appState.Device.device, &fenceCreateInfo, nullptr, &perImage.fence));
	}
	appState.Screen.SwapChain = vrapi_CreateTextureSwapChain3(VRAPI_TEXTURE_TYPE_2D, VK_FORMAT_R8G8B8A8_UNORM, appState.ScreenWidth, appState.ScreenHeight, 1, 1);
	appState.Screen.Data.resize(appState.ScreenWidth * appState.ScreenHeight, 255 << 24);
	appState.Screen.Image = vrapi_GetTextureSwapChainBufferVulkan(appState.Screen.SwapChain, 0);
	auto imageFile = AAssetManager_open(app->activity->assetManager, "play.png", AASSET_MODE_BUFFER);
	auto imageFileLength = AAsset_getLength(imageFile);
	std::vector<stbi_uc> imageSource(imageFileLength);
	AAsset_read(imageFile, imageSource.data(), imageFileLength);
	int imageWidth;
	int imageHeight;
	int imageComponents;
	auto image = stbi_load_from_memory(imageSource.data(), imageFileLength, &imageWidth, &imageHeight, &imageComponents, 4);
	auto texIndex = ((appState.ScreenHeight - imageHeight) * appState.ScreenWidth + appState.ScreenWidth - imageWidth) / 2;
	auto index = 0;
	for (auto y = 0; y < imageHeight; y++)
	{
		for (auto x = 0; x < imageWidth; x++)
		{
			auto r = image[index];
			index++;
			auto g = image[index];
			index++;
			auto b = image[index];
			index++;
			auto a = image[index];
			index++;
			auto factor = (double)a / 255;
			r = (unsigned char)((double)r * factor);
			g = (unsigned char)((double)g * factor);
			b = (unsigned char)((double)b * factor);
			appState.Screen.Data[texIndex] = ((uint32_t)255 << 24) | ((uint32_t)b << 16) | ((uint32_t)g << 8) | r;
			texIndex++;
		}
		texIndex += appState.ScreenWidth - imageWidth;
	}
	stbi_image_free(image);
	for (auto b = 0; b < 5; b++)
	{
		auto i = (unsigned char)(192.0 * sin(M_PI / (double)(b - 1)));
		auto color = ((uint32_t)255 << 24) | ((uint32_t)i << 16) | ((uint32_t)i << 8) | i;
		auto texTopIndex = b * appState.ScreenWidth + b;
		auto texBottomIndex = (appState.ScreenHeight - 1 - b) * appState.ScreenWidth + b;
		for (auto x = 0; x < appState.ScreenWidth - b - b; x++)
		{
			appState.Screen.Data[texTopIndex] = color;
			texTopIndex++;
			appState.Screen.Data[texBottomIndex] = color;
			texBottomIndex++;
		}
		auto texLeftIndex = (b + 1) * appState.ScreenWidth + b;
		auto texRightIndex = (b + 1) * appState.ScreenWidth + appState.ScreenWidth - 1 - b;
		for (auto y = 0; y < appState.ScreenHeight - b - 1 - b - 1; y++)
		{
			appState.Screen.Data[texLeftIndex] = color;
			texLeftIndex += appState.ScreenWidth;
			appState.Screen.Data[texRightIndex] = color;
			texRightIndex += appState.ScreenWidth;
		}
	}
	appState.Screen.Buffer.size = appState.Screen.Data.size() * sizeof(uint32_t);
	VkBufferCreateInfo bufferCreateInfo { };
	bufferCreateInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
	bufferCreateInfo.size = appState.Screen.Buffer.size;
	bufferCreateInfo.usage = VK_BUFFER_USAGE_TRANSFER_SRC_BIT;
	bufferCreateInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE;
	VK(appState.Device.vkCreateBuffer(appState.Device.device, &bufferCreateInfo, nullptr, &appState.Screen.Buffer.buffer));
	appState.Screen.Buffer.flags = VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT;
	VC(appState.Device.vkGetBufferMemoryRequirements(appState.Device.device, appState.Screen.Buffer.buffer, &memoryRequirements));
	createMemoryAllocateInfo(appState, memoryRequirements, appState.Screen.Buffer.flags, memoryAllocateInfo);
	VK(appState.Device.vkAllocateMemory(appState.Device.device, &memoryAllocateInfo, nullptr, &appState.Screen.Buffer.memory));
	VK(appState.Device.vkBindBufferMemory(appState.Device.device, appState.Screen.Buffer.buffer, appState.Screen.Buffer.memory, 0));
	VK(appState.Device.vkMapMemory(appState.Device.device, appState.Screen.Buffer.memory, 0, memoryRequirements.size, 0, &appState.Screen.Buffer.mapped));
	memcpy(appState.Screen.Buffer.mapped, appState.Screen.Data.data(), appState.Screen.Buffer.size);
	VkMappedMemoryRange mappedMemoryRange { };
	mappedMemoryRange.sType = VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE;
	mappedMemoryRange.memory = appState.Screen.Buffer.memory;
	VC(appState.Device.vkFlushMappedMemoryRanges(appState.Device.device, 1, &mappedMemoryRange));
	VC(appState.Device.vkUnmapMemory(appState.Device.device, appState.Screen.Buffer.memory));
	appState.Screen.Buffer.mapped = nullptr;
	VK(appState.Device.vkAllocateCommandBuffers(appState.Device.device, &commandBufferAllocateInfo, &setupCommandBuffer));
	VK(appState.Device.vkBeginCommandBuffer(setupCommandBuffer, &commandBufferBeginInfo));
	imageMemoryBarrier.srcAccessMask = 0;
	imageMemoryBarrier.dstAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;
	imageMemoryBarrier.oldLayout = VK_IMAGE_LAYOUT_UNDEFINED;
	imageMemoryBarrier.newLayout = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL;
	imageMemoryBarrier.image = appState.Screen.Image;
	imageMemoryBarrier.subresourceRange.layerCount = 1;
	VC(appState.Device.vkCmdPipelineBarrier(setupCommandBuffer, VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT, VK_PIPELINE_STAGE_TRANSFER_BIT, 0, 0, nullptr, 0, nullptr, 1, &imageMemoryBarrier));
	VkBufferImageCopy region { };
	region.imageSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
	region.imageSubresource.layerCount = 1;
	region.imageExtent.width = appState.ScreenWidth;
	region.imageExtent.height = appState.ScreenHeight;
	region.imageExtent.depth = 1;
	VC(appState.Device.vkCmdCopyBufferToImage(setupCommandBuffer, appState.Screen.Buffer.buffer, appState.Screen.Image, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, 1, &region));
	VK(appState.Device.vkAllocateCommandBuffers(appState.Device.device, &commandBufferAllocateInfo, &appState.Screen.CommandBuffer));
	appState.Screen.SubmitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;
	appState.Screen.SubmitInfo.commandBufferCount = 1;
	appState.Screen.SubmitInfo.pCommandBuffers = &appState.Screen.CommandBuffer;
	appState.LeftArrows.SwapChain = vrapi_CreateTextureSwapChain3(VRAPI_TEXTURE_TYPE_2D, VK_FORMAT_R8G8B8A8_UNORM, appState.ScreenWidth, appState.ScreenHeight, 1, 1);
	appState.LeftArrows.Data.resize(appState.ScreenWidth * appState.ScreenHeight, 255 << 24);
	appState.LeftArrows.Image = vrapi_GetTextureSwapChainBufferVulkan(appState.LeftArrows.SwapChain, 0);
	imageFile = AAssetManager_open(app->activity->assetManager, "leftarrows.png", AASSET_MODE_BUFFER);
	imageFileLength = AAsset_getLength(imageFile);
	imageSource.resize(imageFileLength);
	AAsset_read(imageFile, imageSource.data(), imageFileLength);
	image = stbi_load_from_memory(imageSource.data(), imageFileLength, &imageWidth, &imageHeight, &imageComponents, 4);
	texIndex = ((appState.ScreenHeight - imageHeight) * appState.ScreenWidth + appState.ScreenWidth - imageWidth) / 2;
	index = 0;
	for (auto y = 0; y < imageHeight; y++)
	{
		for (auto x = 0; x < imageWidth; x++)
		{
			auto r = image[index];
			index++;
			auto g = image[index];
			index++;
			auto b = image[index];
			index++;
			auto a = image[index];
			index++;
			auto factor = (double)a / 255;
			r = (unsigned char)((double)r * factor);
			g = (unsigned char)((double)g * factor);
			b = (unsigned char)((double)b * factor);
			appState.LeftArrows.Data[texIndex] = ((uint32_t)255 << 24) | ((uint32_t)b << 16) | ((uint32_t)g << 8) | r;
			texIndex++;
		}
		texIndex += appState.ScreenWidth - imageWidth;
	}
	stbi_image_free(image);
	appState.LeftArrows.Buffer.size = appState.LeftArrows.Data.size() * sizeof(uint32_t);
	bufferCreateInfo.size = appState.LeftArrows.Buffer.size;
	VK(appState.Device.vkCreateBuffer(appState.Device.device, &bufferCreateInfo, nullptr, &appState.LeftArrows.Buffer.buffer));
	appState.LeftArrows.Buffer.flags = VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT;
	VC(appState.Device.vkGetBufferMemoryRequirements(appState.Device.device, appState.LeftArrows.Buffer.buffer, &memoryRequirements));
	createMemoryAllocateInfo(appState, memoryRequirements, appState.LeftArrows.Buffer.flags, memoryAllocateInfo);
	VK(appState.Device.vkAllocateMemory(appState.Device.device, &memoryAllocateInfo, nullptr, &appState.LeftArrows.Buffer.memory));
	VK(appState.Device.vkBindBufferMemory(appState.Device.device, appState.LeftArrows.Buffer.buffer, appState.LeftArrows.Buffer.memory, 0));
	VK(appState.Device.vkMapMemory(appState.Device.device, appState.LeftArrows.Buffer.memory, 0, memoryRequirements.size, 0, &appState.LeftArrows.Buffer.mapped));
	memcpy(appState.LeftArrows.Buffer.mapped, appState.LeftArrows.Data.data(), appState.LeftArrows.Buffer.size);
	mappedMemoryRange.memory = appState.LeftArrows.Buffer.memory;
	VC(appState.Device.vkFlushMappedMemoryRanges(appState.Device.device, 1, &mappedMemoryRange));
	VC(appState.Device.vkUnmapMemory(appState.Device.device, appState.LeftArrows.Buffer.memory));
	appState.LeftArrows.Buffer.mapped = nullptr;
	imageMemoryBarrier.srcAccessMask = 0;
	imageMemoryBarrier.dstAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;
	imageMemoryBarrier.oldLayout = VK_IMAGE_LAYOUT_UNDEFINED;
	imageMemoryBarrier.newLayout = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL;
	imageMemoryBarrier.image = appState.LeftArrows.Image;
	VC(appState.Device.vkCmdPipelineBarrier(setupCommandBuffer, VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT, VK_PIPELINE_STAGE_TRANSFER_BIT, 0, 0, nullptr, 0, nullptr, 1, &imageMemoryBarrier));
	VC(appState.Device.vkCmdCopyBufferToImage(setupCommandBuffer, appState.LeftArrows.Buffer.buffer, appState.LeftArrows.Image, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, 1, &region));
	appState.RightArrows.SwapChain = vrapi_CreateTextureSwapChain3(VRAPI_TEXTURE_TYPE_2D, VK_FORMAT_R8G8B8A8_UNORM, appState.ScreenWidth, appState.ScreenHeight, 1, 1);
	appState.RightArrows.Data.resize(appState.ScreenWidth * appState.ScreenHeight, 255 << 24);
	appState.RightArrows.Image = vrapi_GetTextureSwapChainBufferVulkan(appState.RightArrows.SwapChain, 0);
	imageFile = AAssetManager_open(app->activity->assetManager, "rightarrows.png", AASSET_MODE_BUFFER);
	imageFileLength = AAsset_getLength(imageFile);
	imageSource.resize(imageFileLength);
	AAsset_read(imageFile, imageSource.data(), imageFileLength);
	image = stbi_load_from_memory(imageSource.data(), imageFileLength, &imageWidth, &imageHeight, &imageComponents, 4);
	texIndex = ((appState.ScreenHeight - imageHeight) * appState.ScreenWidth + appState.ScreenWidth - imageWidth) / 2;
	index = 0;
	for (auto y = 0; y < imageHeight; y++)
	{
		for (auto x = 0; x < imageWidth; x++)
		{
			auto r = image[index];
			index++;
			auto g = image[index];
			index++;
			auto b = image[index];
			index++;
			auto a = image[index];
			index++;
			auto factor = (double)a / 255;
			r = (unsigned char)((double)r * factor);
			g = (unsigned char)((double)g * factor);
			b = (unsigned char)((double)b * factor);
			appState.RightArrows.Data[texIndex] = ((uint32_t)255 << 24) | ((uint32_t)b << 16) | ((uint32_t)g << 8) | r;
			texIndex++;
		}
		texIndex += appState.ScreenWidth - imageWidth;
	}
	stbi_image_free(image);
	appState.RightArrows.Buffer.size = appState.RightArrows.Data.size() * sizeof(uint32_t);
	bufferCreateInfo.size = appState.RightArrows.Buffer.size;
	VK(appState.Device.vkCreateBuffer(appState.Device.device, &bufferCreateInfo, nullptr, &appState.RightArrows.Buffer.buffer));
	appState.RightArrows.Buffer.flags = VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT;
	VC(appState.Device.vkGetBufferMemoryRequirements(appState.Device.device, appState.RightArrows.Buffer.buffer, &memoryRequirements));
	createMemoryAllocateInfo(appState, memoryRequirements, appState.RightArrows.Buffer.flags, memoryAllocateInfo);
	VK(appState.Device.vkAllocateMemory(appState.Device.device, &memoryAllocateInfo, nullptr, &appState.RightArrows.Buffer.memory));
	VK(appState.Device.vkBindBufferMemory(appState.Device.device, appState.RightArrows.Buffer.buffer, appState.RightArrows.Buffer.memory, 0));
	VK(appState.Device.vkMapMemory(appState.Device.device, appState.RightArrows.Buffer.memory, 0, memoryRequirements.size, 0, &appState.RightArrows.Buffer.mapped));
	memcpy(appState.RightArrows.Buffer.mapped, appState.RightArrows.Data.data(), appState.RightArrows.Buffer.size);
	mappedMemoryRange.memory = appState.RightArrows.Buffer.memory;
	VC(appState.Device.vkFlushMappedMemoryRanges(appState.Device.device, 1, &mappedMemoryRange));
	VC(appState.Device.vkUnmapMemory(appState.Device.device, appState.RightArrows.Buffer.memory));
	appState.RightArrows.Buffer.mapped = nullptr;
	imageMemoryBarrier.srcAccessMask = 0;
	imageMemoryBarrier.dstAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;
	imageMemoryBarrier.oldLayout = VK_IMAGE_LAYOUT_UNDEFINED;
	imageMemoryBarrier.newLayout = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL;
	imageMemoryBarrier.image = appState.RightArrows.Image;
	VC(appState.Device.vkCmdPipelineBarrier(setupCommandBuffer, VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT, VK_PIPELINE_STAGE_TRANSFER_BIT, 0, 0, nullptr, 0, nullptr, 1, &imageMemoryBarrier));
	VC(appState.Device.vkCmdCopyBufferToImage(setupCommandBuffer, appState.RightArrows.Buffer.buffer, appState.RightArrows.Image, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, 1, &region));
	VK(appState.Device.vkEndCommandBuffer(setupCommandBuffer));
	VK(appState.Device.vkQueueSubmit(appState.Context.queue, 1, &setupSubmitInfo, VK_NULL_HANDLE));
	VK(appState.Device.vkQueueWaitIdle(appState.Context.queue));
	VC(appState.Device.vkFreeCommandBuffers(appState.Device.device, appState.Context.commandPool, 1, &setupCommandBuffer));
	auto consoleBottom = (float)(appState.ConsoleHeight - SBAR_HEIGHT - 24) / appState.ConsoleHeight;
	auto statusBarTop = (float)(appState.ScreenHeight - SBAR_HEIGHT - 24) / appState.ScreenHeight;
	appState.ConsoleVertices.assign({ -1, consoleBottom * 2 - 1, 0, 0, consoleBottom, 1, consoleBottom * 2 - 1, 0, 1, consoleBottom, 1, -1, 0, 1, 0, -1, -1, 0, 0, 0, -1, 1, 0, 0, 1, -1.0 / 3.0, 1, 0, 1, 1, -1.0 / 3.0, statusBarTop * 2 - 1, 0, 1, consoleBottom, -1, statusBarTop * 2 - 1, 0, 0, consoleBottom });
	appState.ConsoleIndices.assign({ 0, 1, 2, 2, 3, 0, 4, 5, 6, 6, 7, 4 });
	imageFile = AAssetManager_open(app->activity->assetManager, "floor.png", AASSET_MODE_BUFFER);
	imageFileLength = AAsset_getLength(imageFile);
	imageSource.resize(imageFileLength);
	AAsset_read(imageFile, imageSource.data(), imageFileLength);
	image = stbi_load_from_memory(imageSource.data(), imageFileLength, &imageWidth, &imageHeight, &imageComponents, 4);
	appState.FloorWidth = imageWidth;
	appState.FloorHeight = imageHeight;
	appState.FloorData.resize(imageWidth * imageHeight);
	memcpy(appState.FloorData.data(), image, appState.FloorData.size() * sizeof(uint32_t));
	stbi_image_free(image);
	appState.NoGameDataData.resize(appState.ScreenWidth * appState.ScreenHeight, 255 << 24);
	imageFile = AAssetManager_open(app->activity->assetManager, "nogamedata.png", AASSET_MODE_BUFFER);
	imageFileLength = AAsset_getLength(imageFile);
	imageSource.resize(imageFileLength);
	AAsset_read(imageFile, imageSource.data(), imageFileLength);
	image = stbi_load_from_memory(imageSource.data(), imageFileLength, &imageWidth, &imageHeight, &imageComponents, 4);
	texIndex = ((appState.ScreenHeight - imageHeight) * appState.ScreenWidth + appState.ScreenWidth - imageWidth) / 2;
	index = 0;
	for (auto y = 0; y < imageHeight; y++)
	{
		for (auto x = 0; x < imageWidth; x++)
		{
			auto r = image[index];
			index++;
			auto g = image[index];
			index++;
			auto b = image[index];
			index++;
			auto a = image[index];
			index++;
			auto factor = (double)a / 255;
			r = (unsigned char)((double)r * factor);
			g = (unsigned char)((double)g * factor);
			b = (unsigned char)((double)b * factor);
			appState.NoGameDataData[texIndex] = ((uint32_t)255 << 24) | ((uint32_t)b << 16) | ((uint32_t)g << 8) | r;
			texIndex++;
		}
		texIndex += appState.ScreenWidth - imageWidth;
	}
	stbi_image_free(image);
	for (auto b = 0; b < 5; b++)
	{
		auto i = (unsigned char)(192.0 * sin(M_PI / (double)(b - 1)));
		auto color = ((uint32_t)255 << 24) | ((uint32_t)i << 16) | ((uint32_t)i << 8) | i;
		auto texTopIndex = b * appState.ScreenWidth + b;
		auto texBottomIndex = (appState.ScreenHeight - 1 - b) * appState.ScreenWidth + b;
		for (auto x = 0; x < appState.ScreenWidth - b - b; x++)
		{
			appState.NoGameDataData[texTopIndex] = color;
			texTopIndex++;
			appState.NoGameDataData[texBottomIndex] = color;
			texBottomIndex++;
		}
		auto texLeftIndex = (b + 1) * appState.ScreenWidth + b;
		auto texRightIndex = (b + 1) * appState.ScreenWidth + appState.ScreenWidth - 1 - b;
		for (auto y = 0; y < appState.ScreenHeight - b - 1 - b - 1; y++)
		{
			appState.NoGameDataData[texLeftIndex] = color;
			texLeftIndex += appState.ScreenWidth;
			appState.NoGameDataData[texRightIndex] = color;
			texRightIndex += appState.ScreenWidth;
		}
	}
	auto isMultiview = appState.Device.supportsMultiview;
	appState.Scene.numBuffers = (isMultiview) ? VRAPI_FRAME_LAYER_EYE_MAX : 1;
	CreateShader(appState, app, (isMultiview ? "shaders/textured_multiview.vert.spv" : "shaders/textured.vert.spv"), &appState.Scene.texturedVertex);
	CreateShader(appState, app, "shaders/textured.frag.spv", &appState.Scene.texturedFragment);
	CreateShader(appState, app, (isMultiview ? "shaders/surface_multiview.vert.spv" : "shaders/surface.vert.spv"), &appState.Scene.surfaceVertex);
	CreateShader(appState, app, "shaders/sprite.frag.spv", &appState.Scene.spritesFragment);
	CreateShader(appState, app, "shaders/turbulent.frag.spv", &appState.Scene.turbulentFragment);
	CreateShader(appState, app, (isMultiview ? "shaders/alias_multiview.vert.spv" : "shaders/alias.vert.spv"), &appState.Scene.aliasVertex);
	CreateShader(appState, app, "shaders/alias.frag.spv", &appState.Scene.aliasFragment);
	CreateShader(appState, app, (isMultiview ? "shaders/viewmodel_multiview.vert.spv" : "shaders/viewmodel.vert.spv"), &appState.Scene.viewmodelVertex);
	CreateShader(appState, app, "shaders/viewmodel.frag.spv", &appState.Scene.viewmodelFragment);
	CreateShader(appState, app, (isMultiview ? "shaders/colored_multiview.vert.spv" : "shaders/colored.vert.spv"), &appState.Scene.coloredVertex);
	CreateShader(appState, app, "shaders/colored.frag.spv", &appState.Scene.coloredFragment);
	CreateShader(appState, app, (isMultiview ? "shaders/sky_multiview.vert.spv" : "shaders/sky.vert.spv"), &appState.Scene.skyVertex);
	CreateShader(appState, app, "shaders/sky.frag.spv", &appState.Scene.skyFragment);
	CreateShader(appState, app, (isMultiview ? "shaders/floor_multiview.vert.spv" : "shaders/floor.vert.spv"), &appState.Scene.floorVertex);
	CreateShader(appState, app, "shaders/floor.frag.spv", &appState.Scene.floorFragment);
	CreateShader(appState, app, "shaders/console.vert.spv", &appState.Scene.consoleVertex);
	CreateShader(appState, app, "shaders/console.frag.spv", &appState.Scene.consoleFragment);
	VkPipelineTessellationStateCreateInfo tessellationStateCreateInfo { };
	tessellationStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO;
	VkPipelineViewportStateCreateInfo viewportStateCreateInfo { };
	viewportStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
	viewportStateCreateInfo.viewportCount = 1;
	viewportStateCreateInfo.scissorCount = 1;
	VkPipelineRasterizationStateCreateInfo rasterizationStateCreateInfo { };
	rasterizationStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
	rasterizationStateCreateInfo.polygonMode = VK_POLYGON_MODE_FILL;
	rasterizationStateCreateInfo.cullMode = VK_CULL_MODE_BACK_BIT;
	rasterizationStateCreateInfo.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
	rasterizationStateCreateInfo.lineWidth = 1.0f;
	VkPipelineMultisampleStateCreateInfo multisampleStateCreateInfo { };
	multisampleStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
	multisampleStateCreateInfo.rasterizationSamples = VK_SAMPLE_COUNT_4_BIT;
	multisampleStateCreateInfo.minSampleShading = 1.0f;
	VkPipelineDepthStencilStateCreateInfo depthStencilStateCreateInfo { };
	depthStencilStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
	depthStencilStateCreateInfo.depthTestEnable = VK_TRUE;
	depthStencilStateCreateInfo.depthWriteEnable = VK_TRUE;
	depthStencilStateCreateInfo.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL;
	depthStencilStateCreateInfo.front.failOp = VK_STENCIL_OP_KEEP;
	depthStencilStateCreateInfo.front.passOp = VK_STENCIL_OP_KEEP;
	depthStencilStateCreateInfo.front.depthFailOp = VK_STENCIL_OP_KEEP;
	depthStencilStateCreateInfo.front.compareOp = VK_COMPARE_OP_ALWAYS;
	depthStencilStateCreateInfo.back.failOp = VK_STENCIL_OP_KEEP;
	depthStencilStateCreateInfo.back.passOp = VK_STENCIL_OP_KEEP;
	depthStencilStateCreateInfo.back.depthFailOp = VK_STENCIL_OP_KEEP;
	depthStencilStateCreateInfo.back.compareOp = VK_COMPARE_OP_ALWAYS;
	depthStencilStateCreateInfo.minDepthBounds = 0.0f;
	depthStencilStateCreateInfo.maxDepthBounds = 1.0f;
	VkPipelineColorBlendAttachmentState colorBlendAttachmentState { };
	colorBlendAttachmentState.blendEnable = VK_TRUE;
	colorBlendAttachmentState.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
	colorBlendAttachmentState.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
	colorBlendAttachmentState.colorBlendOp = VK_BLEND_OP_ADD;
	colorBlendAttachmentState.srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
	colorBlendAttachmentState.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
	colorBlendAttachmentState.alphaBlendOp = VK_BLEND_OP_ADD;
	colorBlendAttachmentState.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
	VkPipelineColorBlendStateCreateInfo colorBlendStateCreateInfo { };
	colorBlendStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
	colorBlendStateCreateInfo.logicOp = VK_LOGIC_OP_CLEAR;
	colorBlendStateCreateInfo.attachmentCount = 1;
	colorBlendStateCreateInfo.pAttachments = &colorBlendAttachmentState;
	VkDynamicState dynamicStateEnables[] = { VK_DYNAMIC_STATE_VIEWPORT, VK_DYNAMIC_STATE_SCISSOR };
	VkPipelineDynamicStateCreateInfo pipelineDynamicStateCreateInfo { };
	pipelineDynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
	pipelineDynamicStateCreateInfo.dynamicStateCount = 2;
	pipelineDynamicStateCreateInfo.pDynamicStates = dynamicStateEnables;
	appState.Scene.texturedAttributes.vertexAttributes.resize(6);
	appState.Scene.texturedAttributes.vertexBindings.resize(3);
	appState.Scene.texturedAttributes.vertexAttributes[0].format = VK_FORMAT_R32G32B32_SFLOAT;
	appState.Scene.texturedAttributes.vertexBindings[0].stride = 3 * sizeof(float);
	appState.Scene.texturedAttributes.vertexAttributes[1].location = 1;
	appState.Scene.texturedAttributes.vertexAttributes[1].binding = 1;
	appState.Scene.texturedAttributes.vertexAttributes[1].format = VK_FORMAT_R32G32_SFLOAT;
	appState.Scene.texturedAttributes.vertexBindings[1].binding = 1;
	appState.Scene.texturedAttributes.vertexBindings[1].stride = 2 * sizeof(float);
	appState.Scene.texturedAttributes.vertexAttributes[2].location = 2;
	appState.Scene.texturedAttributes.vertexAttributes[2].binding = 2;
	appState.Scene.texturedAttributes.vertexAttributes[2].format = VK_FORMAT_R32G32B32A32_SFLOAT;
	appState.Scene.texturedAttributes.vertexAttributes[3].location = 3;
	appState.Scene.texturedAttributes.vertexAttributes[3].binding = 2;
	appState.Scene.texturedAttributes.vertexAttributes[3].format = VK_FORMAT_R32G32B32A32_SFLOAT;
	appState.Scene.texturedAttributes.vertexAttributes[3].offset = 4 * sizeof(float);
	appState.Scene.texturedAttributes.vertexAttributes[4].location = 4;
	appState.Scene.texturedAttributes.vertexAttributes[4].binding = 2;
	appState.Scene.texturedAttributes.vertexAttributes[4].format = VK_FORMAT_R32G32B32A32_SFLOAT;
	appState.Scene.texturedAttributes.vertexAttributes[4].offset = 8 * sizeof(float);
	appState.Scene.texturedAttributes.vertexAttributes[5].location = 5;
	appState.Scene.texturedAttributes.vertexAttributes[5].binding = 2;
	appState.Scene.texturedAttributes.vertexAttributes[5].format = VK_FORMAT_R32G32B32A32_SFLOAT;
	appState.Scene.texturedAttributes.vertexAttributes[5].offset = 12 * sizeof(float);
	appState.Scene.texturedAttributes.vertexBindings[2].binding = 2;
	appState.Scene.texturedAttributes.vertexBindings[2].stride = 16 * sizeof(float);
	appState.Scene.texturedAttributes.vertexBindings[2].inputRate = VK_VERTEX_INPUT_RATE_INSTANCE;
	appState.Scene.texturedAttributes.vertexInputState.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
	appState.Scene.texturedAttributes.vertexInputState.vertexBindingDescriptionCount = appState.Scene.texturedAttributes.vertexBindings.size();
	appState.Scene.texturedAttributes.vertexInputState.pVertexBindingDescriptions = appState.Scene.texturedAttributes.vertexBindings.data();
	appState.Scene.texturedAttributes.vertexInputState.vertexAttributeDescriptionCount = appState.Scene.texturedAttributes.vertexAttributes.size();
	appState.Scene.texturedAttributes.vertexInputState.pVertexAttributeDescriptions = appState.Scene.texturedAttributes.vertexAttributes.data();
	appState.Scene.texturedAttributes.inputAssemblyState.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
	appState.Scene.texturedAttributes.inputAssemblyState.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP;
	appState.Scene.colormappedAttributes.vertexAttributes.resize(7);
	appState.Scene.colormappedAttributes.vertexBindings.resize(4);
	appState.Scene.colormappedAttributes.vertexAttributes[0].format = VK_FORMAT_R32G32B32A32_SFLOAT;
	appState.Scene.colormappedAttributes.vertexBindings[0].stride = 4 * sizeof(float);
	appState.Scene.colormappedAttributes.vertexAttributes[1].location = 1;
	appState.Scene.colormappedAttributes.vertexAttributes[1].binding = 1;
	appState.Scene.colormappedAttributes.vertexAttributes[1].format = VK_FORMAT_R32G32_SFLOAT;
	appState.Scene.colormappedAttributes.vertexBindings[1].binding = 1;
	appState.Scene.colormappedAttributes.vertexBindings[1].stride = 2 * sizeof(float);
	appState.Scene.colormappedAttributes.vertexAttributes[2].location = 2;
	appState.Scene.colormappedAttributes.vertexAttributes[2].binding = 2;
	appState.Scene.colormappedAttributes.vertexAttributes[2].format = VK_FORMAT_R32_SFLOAT;
	appState.Scene.colormappedAttributes.vertexBindings[2].binding = 2;
	appState.Scene.colormappedAttributes.vertexBindings[2].stride = sizeof(float);
	appState.Scene.colormappedAttributes.vertexAttributes[3].location = 3;
	appState.Scene.colormappedAttributes.vertexAttributes[3].binding = 3;
	appState.Scene.colormappedAttributes.vertexAttributes[3].format = VK_FORMAT_R32G32B32A32_SFLOAT;
	appState.Scene.colormappedAttributes.vertexAttributes[4].location = 4;
	appState.Scene.colormappedAttributes.vertexAttributes[4].binding = 3;
	appState.Scene.colormappedAttributes.vertexAttributes[4].format = VK_FORMAT_R32G32B32A32_SFLOAT;
	appState.Scene.colormappedAttributes.vertexAttributes[4].offset = 4 * sizeof(float);
	appState.Scene.colormappedAttributes.vertexAttributes[5].location = 5;
	appState.Scene.colormappedAttributes.vertexAttributes[5].binding = 3;
	appState.Scene.colormappedAttributes.vertexAttributes[5].format = VK_FORMAT_R32G32B32A32_SFLOAT;
	appState.Scene.colormappedAttributes.vertexAttributes[5].offset = 8 * sizeof(float);
	appState.Scene.colormappedAttributes.vertexAttributes[6].location = 6;
	appState.Scene.colormappedAttributes.vertexAttributes[6].binding = 3;
	appState.Scene.colormappedAttributes.vertexAttributes[6].format = VK_FORMAT_R32G32B32A32_SFLOAT;
	appState.Scene.colormappedAttributes.vertexAttributes[6].offset = 12 * sizeof(float);
	appState.Scene.colormappedAttributes.vertexBindings[3].binding = 3;
	appState.Scene.colormappedAttributes.vertexBindings[3].stride = 16 * sizeof(float);
	appState.Scene.colormappedAttributes.vertexBindings[3].inputRate = VK_VERTEX_INPUT_RATE_INSTANCE;
	appState.Scene.colormappedAttributes.vertexInputState.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
	appState.Scene.colormappedAttributes.vertexInputState.vertexBindingDescriptionCount = appState.Scene.colormappedAttributes.vertexBindings.size();
	appState.Scene.colormappedAttributes.vertexInputState.pVertexBindingDescriptions = appState.Scene.colormappedAttributes.vertexBindings.data();
	appState.Scene.colormappedAttributes.vertexInputState.vertexAttributeDescriptionCount = appState.Scene.colormappedAttributes.vertexAttributes.size();
	appState.Scene.colormappedAttributes.vertexInputState.pVertexAttributeDescriptions = appState.Scene.colormappedAttributes.vertexAttributes.data();
	appState.Scene.colormappedAttributes.inputAssemblyState.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
	appState.Scene.colormappedAttributes.inputAssemblyState.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
	appState.Scene.coloredAttributes.vertexAttributes.resize(6);
	appState.Scene.coloredAttributes.vertexBindings.resize(3);
	appState.Scene.coloredAttributes.vertexAttributes[0].format = VK_FORMAT_R32G32B32_SFLOAT;
	appState.Scene.coloredAttributes.vertexBindings[0].stride = 3 * sizeof(float);
	appState.Scene.coloredAttributes.vertexAttributes[1].location = 1;
	appState.Scene.coloredAttributes.vertexAttributes[1].binding = 1;
	appState.Scene.coloredAttributes.vertexAttributes[1].format = VK_FORMAT_R32G32B32A32_SFLOAT;
	appState.Scene.coloredAttributes.vertexAttributes[2].location = 2;
	appState.Scene.coloredAttributes.vertexAttributes[2].binding = 1;
	appState.Scene.coloredAttributes.vertexAttributes[2].format = VK_FORMAT_R32G32B32A32_SFLOAT;
	appState.Scene.coloredAttributes.vertexAttributes[2].offset = 4 * sizeof(float);
	appState.Scene.coloredAttributes.vertexAttributes[3].location = 3;
	appState.Scene.coloredAttributes.vertexAttributes[3].binding = 1;
	appState.Scene.coloredAttributes.vertexAttributes[3].format = VK_FORMAT_R32G32B32A32_SFLOAT;
	appState.Scene.coloredAttributes.vertexAttributes[3].offset = 8 * sizeof(float);
	appState.Scene.coloredAttributes.vertexAttributes[4].location = 4;
	appState.Scene.coloredAttributes.vertexAttributes[4].binding = 1;
	appState.Scene.coloredAttributes.vertexAttributes[4].format = VK_FORMAT_R32G32B32A32_SFLOAT;
	appState.Scene.coloredAttributes.vertexAttributes[4].offset = 12 * sizeof(float);
	appState.Scene.coloredAttributes.vertexBindings[1].binding = 1;
	appState.Scene.coloredAttributes.vertexBindings[1].stride = 16 * sizeof(float);
	appState.Scene.coloredAttributes.vertexBindings[1].inputRate = VK_VERTEX_INPUT_RATE_INSTANCE;
	appState.Scene.coloredAttributes.vertexAttributes[5].location = 5;
	appState.Scene.coloredAttributes.vertexAttributes[5].binding = 2;
	appState.Scene.coloredAttributes.vertexAttributes[5].format = VK_FORMAT_R32_SFLOAT;
	appState.Scene.coloredAttributes.vertexBindings[2].binding = 2;
	appState.Scene.coloredAttributes.vertexBindings[2].stride = sizeof(float);
	appState.Scene.coloredAttributes.vertexInputState.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
	appState.Scene.coloredAttributes.vertexInputState.vertexBindingDescriptionCount = appState.Scene.coloredAttributes.vertexBindings.size();
	appState.Scene.coloredAttributes.vertexInputState.pVertexBindingDescriptions = appState.Scene.coloredAttributes.vertexBindings.data();
	appState.Scene.coloredAttributes.vertexInputState.vertexAttributeDescriptionCount = appState.Scene.coloredAttributes.vertexAttributes.size();
	appState.Scene.coloredAttributes.vertexInputState.pVertexAttributeDescriptions = appState.Scene.coloredAttributes.vertexAttributes.data();
	appState.Scene.coloredAttributes.inputAssemblyState.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
	appState.Scene.coloredAttributes.inputAssemblyState.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
	appState.Scene.skyAttributes.vertexAttributes.resize(2);
	appState.Scene.skyAttributes.vertexBindings.resize(2);
	appState.Scene.skyAttributes.vertexAttributes[0].format = VK_FORMAT_R32G32B32_SFLOAT;
	appState.Scene.skyAttributes.vertexBindings[0].stride = 3 * sizeof(float);
	appState.Scene.skyAttributes.vertexAttributes[1].location = 1;
	appState.Scene.skyAttributes.vertexAttributes[1].binding = 1;
	appState.Scene.skyAttributes.vertexAttributes[1].format = VK_FORMAT_R32G32_SFLOAT;
	appState.Scene.skyAttributes.vertexBindings[1].binding = 1;
	appState.Scene.skyAttributes.vertexBindings[1].stride = 2 * sizeof(float);
	appState.Scene.skyAttributes.vertexInputState.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
	appState.Scene.skyAttributes.vertexInputState.vertexBindingDescriptionCount = appState.Scene.skyAttributes.vertexBindings.size();
	appState.Scene.skyAttributes.vertexInputState.pVertexBindingDescriptions = appState.Scene.skyAttributes.vertexBindings.data();
	appState.Scene.skyAttributes.vertexInputState.vertexAttributeDescriptionCount = appState.Scene.skyAttributes.vertexAttributes.size();
	appState.Scene.skyAttributes.vertexInputState.pVertexAttributeDescriptions = appState.Scene.skyAttributes.vertexAttributes.data();
	appState.Scene.skyAttributes.inputAssemblyState.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
	appState.Scene.skyAttributes.inputAssemblyState.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP;
	appState.Scene.floorAttributes.vertexAttributes.resize(2);
	appState.Scene.floorAttributes.vertexBindings.resize(2);
	appState.Scene.floorAttributes.vertexAttributes[0].format = VK_FORMAT_R32G32B32_SFLOAT;
	appState.Scene.floorAttributes.vertexBindings[0].stride = 3 * sizeof(float);
	appState.Scene.floorAttributes.vertexAttributes[1].location = 1;
	appState.Scene.floorAttributes.vertexAttributes[1].binding = 1;
	appState.Scene.floorAttributes.vertexAttributes[1].format = VK_FORMAT_R32G32_SFLOAT;
	appState.Scene.floorAttributes.vertexBindings[1].binding = 1;
	appState.Scene.floorAttributes.vertexBindings[1].stride = 2 * sizeof(float);
	appState.Scene.floorAttributes.vertexInputState.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
	appState.Scene.floorAttributes.vertexInputState.vertexBindingDescriptionCount = appState.Scene.floorAttributes.vertexBindings.size();
	appState.Scene.floorAttributes.vertexInputState.pVertexBindingDescriptions = appState.Scene.floorAttributes.vertexBindings.data();
	appState.Scene.floorAttributes.vertexInputState.vertexAttributeDescriptionCount = appState.Scene.floorAttributes.vertexAttributes.size();
	appState.Scene.floorAttributes.vertexInputState.pVertexAttributeDescriptions = appState.Scene.floorAttributes.vertexAttributes.data();
	appState.Scene.floorAttributes.inputAssemblyState.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
	appState.Scene.floorAttributes.inputAssemblyState.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
	appState.Scene.consoleAttributes.vertexAttributes.resize(2);
	appState.Scene.consoleAttributes.vertexBindings.resize(2);
	appState.Scene.consoleAttributes.vertexAttributes[0].format = VK_FORMAT_R32G32B32_SFLOAT;
	appState.Scene.consoleAttributes.vertexBindings[0].stride = 5 * sizeof(float);
	appState.Scene.consoleAttributes.vertexAttributes[1].location = 1;
	appState.Scene.consoleAttributes.vertexAttributes[1].binding = 1;
	appState.Scene.consoleAttributes.vertexAttributes[1].format = VK_FORMAT_R32G32_SFLOAT;
	appState.Scene.consoleAttributes.vertexAttributes[1].offset = 3 * sizeof(float);
	appState.Scene.consoleAttributes.vertexBindings[1].binding = 1;
	appState.Scene.consoleAttributes.vertexBindings[1].stride = 5 * sizeof(float);
	appState.Scene.consoleAttributes.vertexInputState.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
	appState.Scene.consoleAttributes.vertexInputState.vertexBindingDescriptionCount = appState.Scene.consoleAttributes.vertexBindings.size();
	appState.Scene.consoleAttributes.vertexInputState.pVertexBindingDescriptions = appState.Scene.consoleAttributes.vertexBindings.data();
	appState.Scene.consoleAttributes.vertexInputState.vertexAttributeDescriptionCount = appState.Scene.consoleAttributes.vertexAttributes.size();
	appState.Scene.consoleAttributes.vertexInputState.pVertexAttributeDescriptions = appState.Scene.consoleAttributes.vertexAttributes.data();
	appState.Scene.consoleAttributes.inputAssemblyState.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
	appState.Scene.consoleAttributes.inputAssemblyState.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
	appState.Scene.textured.stages.resize(2);
	appState.Scene.textured.stages[0].sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
	appState.Scene.textured.stages[0].stage = VK_SHADER_STAGE_VERTEX_BIT;
	appState.Scene.textured.stages[0].module = appState.Scene.surfaceVertex;
	appState.Scene.textured.stages[0].pName = "main";
	appState.Scene.textured.stages[1].sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
	appState.Scene.textured.stages[1].stage = VK_SHADER_STAGE_FRAGMENT_BIT;
	appState.Scene.textured.stages[1].module = appState.Scene.texturedFragment;
	appState.Scene.textured.stages[1].pName = "main";
	VkDescriptorSetLayoutBinding descriptorSetBindings[2] { };
	descriptorSetBindings[1].binding = 1;
	VkDescriptorSetLayoutCreateInfo descriptorSetLayoutCreateInfo { };
	descriptorSetLayoutCreateInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
	descriptorSetLayoutCreateInfo.pBindings = descriptorSetBindings;
	descriptorSetBindings[0].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
	descriptorSetBindings[0].descriptorCount = 1;
	descriptorSetBindings[0].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
	descriptorSetLayoutCreateInfo.bindingCount = 1;
	VK(appState.Device.vkCreateDescriptorSetLayout(appState.Device.device, &descriptorSetLayoutCreateInfo, nullptr, &appState.Scene.singleBufferLayout));
	descriptorSetBindings[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
	descriptorSetBindings[1].descriptorCount = 1;
	descriptorSetBindings[1].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
	descriptorSetLayoutCreateInfo.bindingCount = 2;
	VK(appState.Device.vkCreateDescriptorSetLayout(appState.Device.device, &descriptorSetLayoutCreateInfo, nullptr, &appState.Scene.bufferAndImageLayout));
	descriptorSetBindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
	descriptorSetBindings[0].descriptorCount = 1;
	descriptorSetBindings[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
	descriptorSetLayoutCreateInfo.bindingCount = 1;
	VK(appState.Device.vkCreateDescriptorSetLayout(appState.Device.device, &descriptorSetLayoutCreateInfo, nullptr, &appState.Scene.singleImageLayout));
	descriptorSetBindings[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
	descriptorSetBindings[1].descriptorCount = 1;
	descriptorSetBindings[1].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
	descriptorSetLayoutCreateInfo.bindingCount = 2;
	VK(appState.Device.vkCreateDescriptorSetLayout(appState.Device.device, &descriptorSetLayoutCreateInfo, nullptr, &appState.Scene.doubleImageLayout));
	VkDescriptorSetLayout descriptorSetLayouts[3] { };
	descriptorSetLayouts[0] = appState.Scene.bufferAndImageLayout;
	descriptorSetLayouts[1] = appState.Scene.singleImageLayout;
	VkPipelineLayoutCreateInfo pipelineLayoutCreateInfo { };
	pipelineLayoutCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
	pipelineLayoutCreateInfo.setLayoutCount = 2;
	pipelineLayoutCreateInfo.pSetLayouts = descriptorSetLayouts;
	VkPushConstantRange pushConstantInfo { };
	pushConstantInfo.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
	pushConstantInfo.size = 3 * sizeof(float);
	pipelineLayoutCreateInfo.pushConstantRangeCount = 1;
	pipelineLayoutCreateInfo.pPushConstantRanges = &pushConstantInfo;
	VK(appState.Device.vkCreatePipelineLayout(appState.Device.device, &pipelineLayoutCreateInfo, nullptr, &appState.Scene.textured.pipelineLayout));
	VkGraphicsPipelineCreateInfo graphicsPipelineCreateInfo { };
	graphicsPipelineCreateInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
	graphicsPipelineCreateInfo.stageCount = appState.Scene.textured.stages.size();
	graphicsPipelineCreateInfo.pStages = appState.Scene.textured.stages.data();
	graphicsPipelineCreateInfo.pVertexInputState = &appState.Scene.texturedAttributes.vertexInputState;
	graphicsPipelineCreateInfo.pInputAssemblyState = &appState.Scene.texturedAttributes.inputAssemblyState;
	graphicsPipelineCreateInfo.pTessellationState = &tessellationStateCreateInfo;
	graphicsPipelineCreateInfo.pViewportState = &viewportStateCreateInfo;
	graphicsPipelineCreateInfo.pRasterizationState = &rasterizationStateCreateInfo;
	graphicsPipelineCreateInfo.pMultisampleState = &multisampleStateCreateInfo;
	graphicsPipelineCreateInfo.pDepthStencilState = &depthStencilStateCreateInfo;
	graphicsPipelineCreateInfo.pColorBlendState = &colorBlendStateCreateInfo;
	graphicsPipelineCreateInfo.pDynamicState = &pipelineDynamicStateCreateInfo;
	graphicsPipelineCreateInfo.layout = appState.Scene.textured.pipelineLayout;
	graphicsPipelineCreateInfo.renderPass = appState.RenderPass;
	VK(appState.Device.vkCreateGraphicsPipelines(appState.Device.device, appState.Context.pipelineCache, 1, &graphicsPipelineCreateInfo, nullptr, &appState.Scene.textured.pipeline));
	appState.Scene.sprites.stages.resize(2);
	appState.Scene.sprites.stages[0].sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
	appState.Scene.sprites.stages[0].stage = VK_SHADER_STAGE_VERTEX_BIT;
	appState.Scene.sprites.stages[0].module = appState.Scene.texturedVertex;
	appState.Scene.sprites.stages[0].pName = "main";
	appState.Scene.sprites.stages[1].sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
	appState.Scene.sprites.stages[1].stage = VK_SHADER_STAGE_FRAGMENT_BIT;
	appState.Scene.sprites.stages[1].module = appState.Scene.spritesFragment;
	appState.Scene.sprites.stages[1].pName = "main";
	pipelineLayoutCreateInfo.pushConstantRangeCount = 0;
	pipelineLayoutCreateInfo.pPushConstantRanges = nullptr;
	VK(appState.Device.vkCreatePipelineLayout(appState.Device.device, &pipelineLayoutCreateInfo, nullptr, &appState.Scene.sprites.pipelineLayout));
	graphicsPipelineCreateInfo.stageCount = appState.Scene.sprites.stages.size();
	graphicsPipelineCreateInfo.pStages = appState.Scene.sprites.stages.data();
	graphicsPipelineCreateInfo.layout = appState.Scene.sprites.pipelineLayout;
	VK(appState.Device.vkCreateGraphicsPipelines(appState.Device.device, appState.Context.pipelineCache, 1, &graphicsPipelineCreateInfo, nullptr, &appState.Scene.sprites.pipeline));
	appState.Scene.turbulent.stages.resize(2);
	appState.Scene.turbulent.stages[0].sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
	appState.Scene.turbulent.stages[0].stage = VK_SHADER_STAGE_VERTEX_BIT;
	appState.Scene.turbulent.stages[0].module = appState.Scene.surfaceVertex;
	appState.Scene.turbulent.stages[0].pName = "main";
	appState.Scene.turbulent.stages[1].sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
	appState.Scene.turbulent.stages[1].stage = VK_SHADER_STAGE_FRAGMENT_BIT;
	appState.Scene.turbulent.stages[1].module = appState.Scene.turbulentFragment;
	appState.Scene.turbulent.stages[1].pName = "main";
	pushConstantInfo.stageFlags = VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_FRAGMENT_BIT;
	pushConstantInfo.size = 4 * sizeof(float);
	pipelineLayoutCreateInfo.pushConstantRangeCount = 1;
	pipelineLayoutCreateInfo.pPushConstantRanges = &pushConstantInfo;
	VK(appState.Device.vkCreatePipelineLayout(appState.Device.device, &pipelineLayoutCreateInfo, nullptr, &appState.Scene.turbulent.pipelineLayout));
	graphicsPipelineCreateInfo.stageCount = appState.Scene.turbulent.stages.size();
	graphicsPipelineCreateInfo.pStages = appState.Scene.turbulent.stages.data();
	graphicsPipelineCreateInfo.layout = appState.Scene.turbulent.pipelineLayout;
	VK(appState.Device.vkCreateGraphicsPipelines(appState.Device.device, appState.Context.pipelineCache, 1, &graphicsPipelineCreateInfo, nullptr, &appState.Scene.turbulent.pipeline));
	appState.Scene.alias.stages.resize(2);
	appState.Scene.alias.stages[0].sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
	appState.Scene.alias.stages[0].stage = VK_SHADER_STAGE_VERTEX_BIT;
	appState.Scene.alias.stages[0].module = appState.Scene.aliasVertex;
	appState.Scene.alias.stages[0].pName = "main";
	appState.Scene.alias.stages[1].sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
	appState.Scene.alias.stages[1].stage = VK_SHADER_STAGE_FRAGMENT_BIT;
	appState.Scene.alias.stages[1].module = appState.Scene.aliasFragment;
	appState.Scene.alias.stages[1].pName = "main";
	pushConstantInfo.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
	pushConstantInfo.size = 16 * sizeof(float);
	pipelineLayoutCreateInfo.pushConstantRangeCount = 1;
	pipelineLayoutCreateInfo.pPushConstantRanges = &pushConstantInfo;
	descriptorSetLayouts[2] = appState.Scene.singleImageLayout;
	pipelineLayoutCreateInfo.setLayoutCount = 3;
	VK(appState.Device.vkCreatePipelineLayout(appState.Device.device, &pipelineLayoutCreateInfo, nullptr, &appState.Scene.alias.pipelineLayout));
	graphicsPipelineCreateInfo.stageCount = appState.Scene.alias.stages.size();
	graphicsPipelineCreateInfo.pStages = appState.Scene.alias.stages.data();
	graphicsPipelineCreateInfo.pVertexInputState = &appState.Scene.colormappedAttributes.vertexInputState;
	graphicsPipelineCreateInfo.pInputAssemblyState = &appState.Scene.colormappedAttributes.inputAssemblyState;
	graphicsPipelineCreateInfo.layout = appState.Scene.alias.pipelineLayout;
	VK(appState.Device.vkCreateGraphicsPipelines(appState.Device.device, appState.Context.pipelineCache, 1, &graphicsPipelineCreateInfo, nullptr, &appState.Scene.alias.pipeline));
	appState.Scene.viewmodel.stages.resize(2);
	appState.Scene.viewmodel.stages[0].sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
	appState.Scene.viewmodel.stages[0].stage = VK_SHADER_STAGE_VERTEX_BIT;
	appState.Scene.viewmodel.stages[0].module = appState.Scene.viewmodelVertex;
	appState.Scene.viewmodel.stages[0].pName = "main";
	appState.Scene.viewmodel.stages[1].sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
	appState.Scene.viewmodel.stages[1].stage = VK_SHADER_STAGE_FRAGMENT_BIT;
	appState.Scene.viewmodel.stages[1].module = appState.Scene.viewmodelFragment;
	appState.Scene.viewmodel.stages[1].pName = "main";
	pushConstantInfo.stageFlags = VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_FRAGMENT_BIT;
	pushConstantInfo.size = 24 * sizeof(float);
	VK(appState.Device.vkCreatePipelineLayout(appState.Device.device, &pipelineLayoutCreateInfo, nullptr, &appState.Scene.viewmodel.pipelineLayout));
	graphicsPipelineCreateInfo.stageCount = appState.Scene.viewmodel.stages.size();
	graphicsPipelineCreateInfo.pStages = appState.Scene.viewmodel.stages.data();
	graphicsPipelineCreateInfo.layout = appState.Scene.viewmodel.pipelineLayout;
	VK(appState.Device.vkCreateGraphicsPipelines(appState.Device.device, appState.Context.pipelineCache, 1, &graphicsPipelineCreateInfo, nullptr, &appState.Scene.viewmodel.pipeline));
	appState.Scene.colored.stages.resize(2);
	appState.Scene.colored.stages[0].sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
	appState.Scene.colored.stages[0].stage = VK_SHADER_STAGE_VERTEX_BIT;
	appState.Scene.colored.stages[0].module = appState.Scene.coloredVertex;
	appState.Scene.colored.stages[0].pName = "main";
	appState.Scene.colored.stages[1].sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
	appState.Scene.colored.stages[1].stage = VK_SHADER_STAGE_FRAGMENT_BIT;
	appState.Scene.colored.stages[1].module = appState.Scene.coloredFragment;
	appState.Scene.colored.stages[1].pName = "main";
	pipelineLayoutCreateInfo.pushConstantRangeCount = 0;
	pipelineLayoutCreateInfo.pPushConstantRanges = nullptr;
	pipelineLayoutCreateInfo.setLayoutCount = 1;
	pipelineLayoutCreateInfo.pSetLayouts = &appState.Scene.bufferAndImageLayout;
	VK(appState.Device.vkCreatePipelineLayout(appState.Device.device, &pipelineLayoutCreateInfo, nullptr, &appState.Scene.colored.pipelineLayout));
	graphicsPipelineCreateInfo.stageCount = appState.Scene.colored.stages.size();
	graphicsPipelineCreateInfo.pStages = appState.Scene.colored.stages.data();
	graphicsPipelineCreateInfo.pVertexInputState = &appState.Scene.coloredAttributes.vertexInputState;
	graphicsPipelineCreateInfo.pInputAssemblyState = &appState.Scene.coloredAttributes.inputAssemblyState;
	graphicsPipelineCreateInfo.layout = appState.Scene.colored.pipelineLayout;
	VK(appState.Device.vkCreateGraphicsPipelines(appState.Device.device, appState.Context.pipelineCache, 1, &graphicsPipelineCreateInfo, nullptr, &appState.Scene.colored.pipeline));
	appState.Scene.sky.stages.resize(2);
	appState.Scene.sky.stages[0].sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
	appState.Scene.sky.stages[0].stage = VK_SHADER_STAGE_VERTEX_BIT;
	appState.Scene.sky.stages[0].module = appState.Scene.skyVertex;
	appState.Scene.sky.stages[0].pName = "main";
	appState.Scene.sky.stages[1].sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
	appState.Scene.sky.stages[1].stage = VK_SHADER_STAGE_FRAGMENT_BIT;
	appState.Scene.sky.stages[1].module = appState.Scene.skyFragment;
	appState.Scene.sky.stages[1].pName = "main";
	pushConstantInfo.stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
	pushConstantInfo.size = 13 * sizeof(float);
	pipelineLayoutCreateInfo.pushConstantRangeCount = 1;
	pipelineLayoutCreateInfo.pPushConstantRanges = &pushConstantInfo;
	descriptorSetLayouts[1] = appState.Scene.singleImageLayout;
	pipelineLayoutCreateInfo.setLayoutCount = 2;
	pipelineLayoutCreateInfo.pSetLayouts = descriptorSetLayouts;
	VK(appState.Device.vkCreatePipelineLayout(appState.Device.device, &pipelineLayoutCreateInfo, nullptr, &appState.Scene.sky.pipelineLayout));
	graphicsPipelineCreateInfo.stageCount = appState.Scene.sky.stages.size();
	graphicsPipelineCreateInfo.pStages = appState.Scene.sky.stages.data();
	graphicsPipelineCreateInfo.pVertexInputState = &appState.Scene.skyAttributes.vertexInputState;
	graphicsPipelineCreateInfo.pInputAssemblyState = &appState.Scene.skyAttributes.inputAssemblyState;
	graphicsPipelineCreateInfo.layout = appState.Scene.sky.pipelineLayout;
	VK(appState.Device.vkCreateGraphicsPipelines(appState.Device.device, appState.Context.pipelineCache, 1, &graphicsPipelineCreateInfo, nullptr, &appState.Scene.sky.pipeline));
	appState.Scene.floor.stages.resize(2);
	appState.Scene.floor.stages[0].sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
	appState.Scene.floor.stages[0].stage = VK_SHADER_STAGE_VERTEX_BIT;
	appState.Scene.floor.stages[0].module = appState.Scene.floorVertex;
	appState.Scene.floor.stages[0].pName = "main";
	appState.Scene.floor.stages[1].sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
	appState.Scene.floor.stages[1].stage = VK_SHADER_STAGE_FRAGMENT_BIT;
	appState.Scene.floor.stages[1].module = appState.Scene.floorFragment;
	appState.Scene.floor.stages[1].pName = "main";
	descriptorSetLayouts[0] = appState.Scene.singleBufferLayout;
	descriptorSetLayouts[1] = appState.Scene.singleImageLayout;
	VK(appState.Device.vkCreatePipelineLayout(appState.Device.device, &pipelineLayoutCreateInfo, nullptr, &appState.Scene.floor.pipelineLayout));
	graphicsPipelineCreateInfo.stageCount = appState.Scene.floor.stages.size();
	graphicsPipelineCreateInfo.pStages = appState.Scene.floor.stages.data();
	graphicsPipelineCreateInfo.pVertexInputState = &appState.Scene.floorAttributes.vertexInputState;
	graphicsPipelineCreateInfo.pInputAssemblyState = &appState.Scene.floorAttributes.inputAssemblyState;
	graphicsPipelineCreateInfo.layout = appState.Scene.floor.pipelineLayout;
	VK(appState.Device.vkCreateGraphicsPipelines(appState.Device.device, appState.Context.pipelineCache, 1, &graphicsPipelineCreateInfo, nullptr, &appState.Scene.floor.pipeline));
	appState.Scene.console.stages.resize(2);
	appState.Scene.console.stages[0].sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
	appState.Scene.console.stages[0].stage = VK_SHADER_STAGE_VERTEX_BIT;
	appState.Scene.console.stages[0].module = appState.Scene.consoleVertex;
	appState.Scene.console.stages[0].pName = "main";
	appState.Scene.console.stages[1].sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
	appState.Scene.console.stages[1].stage = VK_SHADER_STAGE_FRAGMENT_BIT;
	appState.Scene.console.stages[1].module = appState.Scene.consoleFragment;
	appState.Scene.console.stages[1].pName = "main";
	pipelineLayoutCreateInfo.pSetLayouts = &appState.Scene.doubleImageLayout;
	pipelineLayoutCreateInfo.setLayoutCount = 1;
	VK(appState.Device.vkCreatePipelineLayout(appState.Device.device, &pipelineLayoutCreateInfo, nullptr, &appState.Scene.console.pipelineLayout));
	graphicsPipelineCreateInfo.stageCount = appState.Scene.console.stages.size();
	graphicsPipelineCreateInfo.pStages = appState.Scene.console.stages.data();
	graphicsPipelineCreateInfo.pVertexInputState = &appState.Scene.consoleAttributes.vertexInputState;
	graphicsPipelineCreateInfo.pInputAssemblyState = &appState.Scene.consoleAttributes.inputAssemblyState;
	graphicsPipelineCreateInfo.layout = appState.Scene.console.pipelineLayout;
	graphicsPipelineCreateInfo.renderPass = appState.Console.RenderPass;
	VK(appState.Device.vkCreateGraphicsPipelines(appState.Device.device, appState.Context.pipelineCache, 1, &graphicsPipelineCreateInfo, nullptr, &appState.Scene.console.pipeline));
	appState.Scene.matrices.size = appState.Scene.numBuffers * 2 * sizeof(ovrMatrix4f);
	bufferCreateInfo.size = appState.Scene.matrices.size;
	bufferCreateInfo.usage = VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT | VK_BUFFER_USAGE_TRANSFER_DST_BIT;
	VK(appState.Device.vkCreateBuffer(appState.Device.device, &bufferCreateInfo, nullptr, &appState.Scene.matrices.buffer));
	appState.Scene.matrices.flags = VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT;
	VC(appState.Device.vkGetBufferMemoryRequirements(appState.Device.device, appState.Scene.matrices.buffer, &memoryRequirements));
	createMemoryAllocateInfo(appState, memoryRequirements, appState.Scene.matrices.flags, memoryAllocateInfo);
	VK(appState.Device.vkAllocateMemory(appState.Device.device, &memoryAllocateInfo, nullptr, &appState.Scene.matrices.memory));
	VK(appState.Device.vkBindBufferMemory(appState.Device.device, appState.Scene.matrices.buffer, appState.Scene.matrices.memory, 0));
}

void Scene::CreateShader(AppState& appState, struct android_app* app, const char* filename, VkShaderModule* shaderModule)
{
	auto file = AAssetManager_open(app->activity->assetManager, filename, AASSET_MODE_BUFFER);
	size_t length = AAsset_getLength(file);
	if ((length % 4) != 0)
	{
		__android_log_print(ANDROID_LOG_ERROR, LOG_TAG, "Scene::CreateShader(): %s is not 4-byte aligned.", filename);
		exit(0);
	}
	std::vector<unsigned char> buffer(length);
	AAsset_read(file, buffer.data(), length);
	VkShaderModuleCreateInfo moduleCreateInfo { };
	moduleCreateInfo.sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO;
	moduleCreateInfo.pCode = (uint32_t *)buffer.data();
	moduleCreateInfo.codeSize = length;
	VK(appState.Device.vkCreateShaderModule(appState.Device.device, &moduleCreateInfo, nullptr, shaderModule));
}

void Scene::ClearBuffersAndSizes()
{
	stagingBufferSize = 0;
	texturedDescriptorSetCount = 0;
	spriteDescriptorSetCount = 0;
	colormapDescriptorSetCount = 0;
	aliasDescriptorSetCount = 0;
	viewmodelDescriptorSetCount = 0;
	floorVerticesSize = 0;
	texturedVerticesSize = 0;
	coloredVerticesSize = 0;
	verticesSize = 0;
	colormappedVerticesSize = 0;
	colormappedTexCoordsSize = 0;
	floorAttributesSize = 0;
	texturedAttributesSize = 0;
	colormappedLightsSize = 0;
	vertexTransformSize = 0;
	attributesSize = 0;
	floorIndicesSize = 0;
	colormappedIndices16Size = 0;
	coloredIndices16Size = 0;
	indices16Size = 0;
	colormappedIndices32Size = 0;
	coloredIndices32Size = 0;
	indices32Size = 0;
	coloredSurfaces16Size = 0;
	coloredSurfaces32Size = 0;
	particles16Size = 0;
	particles32Size = 0;
	colorsSize = 0;
	floorSize = 0;
	vertices = nullptr;
	attributes = nullptr;
	indices16 = nullptr;
	indices32 = nullptr;
	colors = nullptr;
}

void Scene::Reset()
{
	viewmodelsPerKey.clear();
	aliasPerKey.clear();
	latestTextureSharedMemory = nullptr;
	usedInLatestTextureSharedMemory = 0;
	latestColormappedBuffer = nullptr;
	usedInLatestColormappedBuffer = 0;
	colormappedBufferList.clear();
	colormappedTexCoordsPerKey.clear();
	colormappedVerticesPerKey.clear();
	spritesPerKey.clear();
	viewmodelTextures.DisposeFront();
	aliasTextures.DisposeFront();
	spriteTextures.DisposeFront();
	for (auto entry = surfaces.begin(); entry != surfaces.end(); entry++)
	{
		for (TextureFromAllocation** t = &entry->second; *t != nullptr; )
		{
			TextureFromAllocation* next = (*t)->next;
			(*t)->next = oldSurfaces;
			oldSurfaces = *t;
			*t = next;
		}
	}
	surfaces.clear();
	colormappedBuffers.DisposeFront();
	viewmodelTextureCount = 0;
	aliasTextureCount = 0;
	spriteTextureCount = 0;
	resetDescriptorSetsCount++;
	vrapi_DestroyTextureSwapChain(skybox);
	skybox = VK_NULL_HANDLE;
}
